44. 부분집합 구하기(DFS)
자연수 N이 주어지면 1부터 N까지의 원소를 갖는 집합의 부분집합을 모두 출력하는 프로그램
을 작성하세요.
▣ 입력설명
첫 번째 줄에 자연수 N(1<=N<=10)이 주어집니다.
▣ 출력설명
첫 번째 줄부터 각 줄에 하나씩 부분집합을 아래와 출력예제와 같은 순서로 출력한다.
단 공집합은 출력하지 않습니다.
▣ 입력예제 1
3
▣ 출력예제 1
1 2 3
1 2
1 3
1
2 3
2
3

def DFS(x) :
    if x== n + 1:  # 만약에 입력값이 3이면 4가 종착역임, 종료지점에 오면 그때서야 출력해주면 됨
        for i in range(1, n + 1):
            if ch[i] == 1:
                print(i, end=' ')
        print()
        return
    else:
        ch[x] = 1  # 사용한다는 것 (리스트에 1이라고 채워주기)
        DFS(x + 1)
        ch[x] = 0  # 사용하지 않는 것 (리스트에 빵 넣어주기)
        DFS(x + 1)


if __name__ == '__main__':
    n = int(input())
    ch = [0] * (n + 1)  # 원소를 포함시킬지 포함시키지 않을지 결정해주는 거
    DFS(1)

=======================================================================================

45. 합이 같은 부분집합(DFS : 아마존 인터뷰)
N개의 원소로 구성된 자연수 집합이 주어지면, 이 집합을 두 개의 부분집합으로 나누었을 때
두 부분집합의 원소의 합이 서로 같은 경우가 존재하면 “YES"를 출력하고, 그렇지 않으면
”NO"를 출력하는 프로그램을 작성하세요.
둘로 나뉘는 두 부분집합은 서로소 집합이며, 두 부분집합을 합하면 입력으로 주어진 원래의
집합이 되어 합니다.
예를 들어 {1, 3, 5, 6, 7, 10}이 입력되면 {1, 3, 5, 7} = {6, 10} 으로 두 부분집합의 합이
16으로 같은 경우가 존재하는 것을 알 수 있다.
▣ 입력설명
첫 번째 줄에 자연수 N(1<=N<=10)이 주어집니다.
두 번째 줄에 집합의 원소 N개가 주어진다. 각 원소는 중복되지 않는다.
▣ 출력설명
첫 번째 줄에 “YES" 또는 ”NO"를 출력한다.
▣ 입력예제 1
6
1 3 5 6 7 10
▣ 출력예제 1
YES


def DFS(L,sum) :
    if L==n :
        if sum==total-sum) :
            print('YES')
            sys.exit(0) #함수 정의 아니고 아예 프로그램이 끝나는 거, 예스가 참이라면 예스 찍고 프로그램을 종료
    else :
        DFS(L+1, sum+a[L])
        DFS(L+1, sum)

if __name__=='__main__' :
    n=int(input())
    a=list(map(int, input().split()))
    total=sum(a)
    DFS(0,0) #이것을 알지 못했다 *********
    print('NO') #YES안나와서 프로그램이 종료가 안됐으면 NO출력하는 것

== == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == =

46. 바둑이 승차(DFS)
철수는 그의 바둑이들을 데리고 시장에 가려고 한다. 그런데 그의 트럭은 C킬로그램 넘게 태
울수가 없다. 철수는 C를 넘지 않으면서 그의 바둑이들을 가장 무겁게 태우고 싶다.
N마리의 바둑이와 각 바둑이의 무게 W가 주어지면, 철수가 트럭에 태울 수 있는 가장 무거운
무게를 구하는 프로그램을 작성하세요.
▣ 입력설명
첫 번째 줄에 자연수 C(1<=C<=100,000,000)와 N(1<=N<=30)이 주어집니다.
둘째 줄부터 N마리 바둑이의 무게가 주어진다.
▣ 출력설명
첫 번째 줄에 가장 무거운 무게를 출력한다.
▣ 입력예제 1
259 5
81
58
42
33
61
▣ 출력예제 1
242

def DFS(L, sum, tsum):
    global result
    if sum + (total - tsum) < result:  # 지금까지 만든 부분집합 - 앞으로 판단해야 할 바둑이 무게의 합이
        return  # 현재까지 구한 최적의 답 result보다 작다면 더 이상 다음 바둑이들 볼 필요가 없다
    if sum > c:
        return
    if L == n:
        if sum > result:
            result = sum
    else:
        DFS(L + 1, sum + a[L], tsum + a[L])
        DFS(L + 1, sum, tsum + a[L])

if __name__ == "__main__":
    c, n = map(int, input().split())
    a = [0] * n
    result = -2147000000
    for i in range(n):
        a[i] = int(input())
    total = sum(a)
    DFS(0, 0, 0)
    print(result)

=======================================================================================

47. 중복순열 구하기
1부터 N까지 번호가 적힌 구슬이 있습니다. 이 중 중복을 허락하여 M번을 뽑아 일렬로 나열
하는 방법을 모두 출력합니다.
▣ 입력설명
첫 번째 줄에 자연수 N(3<=N<=10)과 M(2<=M<=N) 이 주어집니다.
▣ 출력설명
첫 번째 줄에 결과를 출력합니다. 맨 마지막 총 경우의 수를 출력합니다.
출력순서는 사전순으로 오름차순으로 출력합니다.
▣ 입력예제 1
3 2
▣ 출력예제 1
1 1
1 2
1 3
2 1
2 2
2 3
3 1
3 2
3 3
9

def DFS(x):
    global cnt
    if x==m:
        for i in range(m): #이 부분또한...
                print(res[i], end=' ')
        cnt+=1
        print()
        return
    else :
        for i in range(1,n+1): #1, 2, 3
            res[x]=i #이 부분을 잘못 했었다..
            DFS(x+1)
if __name__=='__main__' :
    n,m=map(int, input().split())
    res=[0]*n
    cnt=0
    DFS(0)
    print(cnt)

=======================================================================================

49. 순열 구하기
1부터 N까지 번호가 적힌 구슬이 있습니다. 이 중 M개를 뽑아 일렬로 나열하는 방법을 모두
출력합니다.
▣ 입력설명
첫 번째 줄에 자연수 N(3<=N<=10)과 M(2<=M<=N) 이 주어집니다.
▣ 출력설명
첫 번째 줄에 결과를 출력합니다. 맨 마지막 총 경우의 수를 출력합니다.
출력순서는 사전순으로 오름차순으로 출력합니다.
▣ 입력예제 1
3 2
▣ 출력예제 1
1 2
1 3
2 1
2 3
3 1
3 2
6

def DFS(x):
    global cnt
    global res
    if x==m:
        for i in range(1,m+1):
                cnt+=1
                print(res[i], end=' ')
        print()
        return()
    else :
        for i in range(1,n+1):
            if ch[i]==0:
                ch[i]=1
                res[x+1]=i
                DFS(x+1)
                ch[i]=0 #******이 부분은 dfs호출되고, 다른 가지로 향할 때

if __name__=='__main__' :
    n, m = map(int, input().split())
    res=[0]*(m+1)
    ch=[0]*(n+1)
    cnt=0
    DFS(0)
    print(int(cnt/m))

=======================================================================================

51. 조합 구하기
이 문제를 베이스로 해서 응용되는 문제가 많이 나온다, 꼭 열심히 암기하고 외우자
1부터 N까지 번호가 적힌 구슬이 있습니다. 이 중 M개를 뽑는 방법의 수를 출력하는 프로그
램을 작성하세요.
▣ 입력설명
첫 번째 줄에 자연수 N(3<=N<=10)과 M(2<=M<=N) 이 주어집니다.
▣ 출력설명
첫 번째 줄에 결과를 출력합니다. 맨 마지막 총 경우의 수를 출력합니다.
출력순서는 사전순으로 오름차순으로 출력합니다.
▣ 입력예제 1
4 2
▣ 출력예제 1
1 2
1 3
1 4
2 3
2 4
3 4
6

def DFS(x,s):
    global ch
    global cnt
    if x==m:
        for j in range(m) :
            print(res[j], end=' ')
        print()
        cnt+=1
    else :
        for i in range(s,n+1):
            res[x]=i #가지를 뻗는 것은 i로부터..D(0,1)에서 1,2,3,4 가지가 뻗어지고
            		 #(for i in range(s,n+1)=> 각각 D(1,2) D(1,3) D(1,4) D(1,5) 로 넘어간다.
                     # 따라서 넘어갈 때 i+1로 넘어가면 되는 것이다
            DFS(x+1,i+1) #레벨은 1 증가하고, s는 i+1 로 변신
if __name__=='__main__' :
    n, m = map(int, input().split())
    res=[0]*m
    cnt=0
    DFS(0,1)
    print(cnt)

=======================================================================================

54. 경로 탐색(그래프 DFS)
방향그래프가 주어지면 1번 정점에서 N번 정점으로 가는 모든 경로의 가지 수를 출력하는 프
로그램을 작성하세요. 아래 그래프에서 1번 정점에서 5번 정점으로 가는 가지 수는

=======================================================================================

55. 최대점수 구하기(DFS)
이번 정보올림피아드대회에서 좋은 성적을 내기 위하여 현수는 선생님이 주신 N개의 문제를
풀려고 합니다. 각 문제는 그것을 풀었을 때 얻는 점수와 푸는데 걸리는 시간이 주어지게 됩
니다. 제한시간 M안에 N개의 문제 중 최대점수를 얻을 수 있도록 해야 합니다. (해당문제는
해당시간이 걸리면 푸는 걸로 간주한다, 한 유형당 한개만 풀 수 있습니다.)
▣ 입력설명
첫 번째 줄에 문제의 개수N(1<=N<=20)과 제한 시간 M(10<=M<=300)이 주어집니다.
두 번째 줄부터 N줄에 걸쳐 문제를 풀었을 때의 점수와 푸는데 걸리는 시간이 주어집니다.
▣ 출력설명
첫 번째 줄에 제한 시간안에 얻을 수 있는 최대 점수를 출력합니다.
▣ 입력예제 1
5 20
10 5
25 12
15 8
6 3
7 4
▣ 출력예제 1
41

def DFS(x,s,time) :
    global res
    if time>m :
        return
    if x==n :
        if s>res:
            res=s
    else : #두가지 경우로 나뉜다. 문제를 푸는 경우와 풀지 않는 경우
        DFS(x+1, s+pv[x] , time+pt[x])
        DFS(x+1, s, time)
if __name__=='__main__' :
    n, m = map(int, input().split())
    pv =list()
    pt=list()
    for i in range(n) :
        a,b = map(int, input().split())
        pv.append(a)
        pt.append(b)
    res=-1
    DFS(0,0,0)
    print(res)

=======================================================================================
