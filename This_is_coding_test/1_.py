기간 복잡도와 공간 복잡도
표기법 : 빅 O 표기법  (가장 빠르게 증가하는 항만을 고려 / 함수의 상한만을 나타냄)

모든 데이터를 한번씩 확인한다 : O(N)
이중 반복문 : O(N^2)

코딩 테스트에서 통상 시간제한은 1초 ~5초 가량인데, 5억을 넘어가는 경우 (5억은 0이8개)
1초에 2천만번

시간제한이 1초
N : 500 : 시간복잡도 O(n3)
N : 2,000 : 시간복잡도 O(n2)
N : 100,000 : 시간복잡도 O(nlogN)
N : 10,000,000 : 시간복잡도 O(n)

1. 지문읽기 및 컴퓨터적 사고
2. 요구사항(복잡도 분석)
3. 문제해결을 위한 아이디어 찾기
4. 소스코드 설계 및 코딩

<프로그램 수행시간 측정>===================================================================
import time
s_time = time.time()

e_time = time.time()
print('time : ', e_time-s_time)

<자료형>===================================================================
정수형
실수형
    실수형을 저장하기 위해 4바이트, 혹은 ㅇ8바이트의 고정된 크기의 메모리를 할당하므로, 컴퓨터 시스템은 실수 정보를  표현하는 정확도에 한계를 가짐
    2진수에는 0.9를 정확히 표현할 수 있는 방법이 없음
    미세한 오차가 발생하게 됨
        a = 0.3
        b = 0.6
        c = a+b     # c(float)0.899999
        c = round(c,1)   # c = 0.9
무한의 값으로 inf = 1e9 (최단 경로 알고리즘에서 도달할 수 없는 노드에 대해 최단 거리를 무한)
    유효숫자e지수  print(2.75e2)  : 275.0

<리스트 자료형>===================================================================
리스트 인덱싱은 뒤쪽에서 -1부터 시작한다 (0이 없으니까)
리스트 컴프리핸션 : 리스트를 초기화하는 방법
    대괄호 안에 조건문과 반복문을 적용하여 리스트를 초기화
메서드 : append, sort, reverse, insert, count, remove
    reverse = True
    sort는 NlogN의 시간 복잡도

            리스트에서 특정한 값을 가지는 원소를 모두 제거하기
            a = [1,2,3,4,5,5,5]
            remove_set = [3,5]
            result = [i for i in a if i not in remove_set]
            print(result)


<문자열>===================================================================
print('akdkflsdjfl\'\'dlsjdlfjs')
문자열은 인덱싱과 슬라이싱을 이용할 수 있다. / 하지만 변경 불가능
a ='abcd'

<튜플>
적은양의 메모리
추천
    서로 다른 성징릐 데이터를 묶어서 관리해야 할 때
        : 최단 경로 알고리즘 (비용, 노드번오)
    데이터의 나열을 해싱(Hashing)의 키 값으로 사용해야 할 때
    효율적 메모리

<사전>===================================================================
키와 값의 쌍을 데이터로 가짐
변경 불가능한 자료형을 키로 사용한다
해시 테이블을 사용, 데이터의 조회 및 수정에 있어 O(1)의 시간에 처리 가능

        data = dict()   # data['key'] = value
        data['사과'] = 'Apple'
        data['파인애플'] = 'Pineapple'
        print(data('사과'))
        data.keys() / data.values()

<집합>===================================================================
중복을 허용하지 않고
순서가 없음

리스트 혹은 문자열을 이용해서 초기화할 수 있음  / set함수 이용
혹은 중괄호 안에 각 원소를 콤마
데이터의 조회 및 수정 O(1)

    data = set([1,2,3,4,4,2,3,2,1,5])
    print(data)
    data = {1,2,3,4,4,2,3,2,1,5}
    print(data)

합집합, 교집합, 차집합 가능  (& |, -)
하나추가, 여러개 추가, 특정 값 삭제는 data.add(4), data.update([5,6]), data.remove(3)


