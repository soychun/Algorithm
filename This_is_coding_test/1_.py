(이코테 2021 강의 몰아보기) 1. 코딩 테스트 출제 경향 분석 및 파이썬 문법 부수기

시간 복잡도와 공간 복잡도
표기법 : 빅 O 표기법  (가장 빠르게 증가하는 항만을 고려 / 함수의 상한만을 나타냄)

모든 데이터를 한번씩 확인한다 : O(N)
이중 반복문 : O(N^2)

코딩 테스트에서 통상 시간제한은 1초 ~5초 가량인데, 5억을 넘어가는 경우 (5억은 0이8개)
1초에 2천만번

시간제한이 1초
N : 500 : 시간복잡도 O(n3)
N : 2,000 : 시간복잡도 O(n2)
N : 100,000 : 시간복잡도 O(nlogN)
N : 10,000,000 : 시간복잡도 O(n)

1. 지문읽기 및 컴퓨터적 사고
2. 요구사항(복잡도 분석)
3. 문제해결을 위한 아이디어 찾기
4. 소스코드 설계 및 코딩

<프로그램 수행시간 측정>===================================================================
import time
s_time = time.time()

e_time = time.time()
print('time : ', e_time-s_time)

<자료형>===================================================================
정수형
실수형
    실수형을 저장하기 위해 4바이트, 혹은 ㅇ8바이트의 고정된 크기의 메모리를 할당하므로, 컴퓨터 시스템은 실수 정보를  표현하는 정확도에 한계를 가짐
    2진수에는 0.9를 정확히 표현할 수 있는 방법이 없음
    미세한 오차가 발생하게 됨
        a = 0.3
        b = 0.6
        c = a+b     # c(float)0.899999
        c = round(c,1)   # c = 0.9
무한의 값으로 inf = 1e9 (최단 경로 알고리즘에서 도달할 수 없는 노드에 대해 최단 거리를 무한)
    유효숫자e지수  print(2.75e2)  : 275.0

<리스트 자료형>===================================================================
리스트 인덱싱은 뒤쪽에서 -1부터 시작한다 (0이 없으니까)
리스트 컴프리핸션 : 리스트를 초기화하는 방법
    대괄호 안에 조건문과 반복문을 적용하여 리스트를 초기화
메서드 : append, sort, reverse, insert, count, remove
    reverse = True
    sort는 NlogN의 시간 복잡도

            리스트에서 특정한 값을 가지는 원소를 모두 제거하기
            a = [1,2,3,4,5,5,5]
            remove_set = [3,5]
            result = [i for i in a if i not in remove_set]
            print(result)


<문자열>===================================================================
print('akdkflsdjfl\'\'dlsjdlfjs')
문자열은 인덱싱과 슬라이싱을 이용할 수 있다. / 하지만 변경 불가능
a ='abcd'

<튜플>
적은양의 메모리
추천
    서로 다른 성징릐 데이터를 묶어서 관리해야 할 때
        : 최단 경로 알고리즘 (비용, 노드번오)
    데이터의 나열을 해싱(Hashing)의 키 값으로 사용해야 할 때
    효율적 메모리

<사전>===================================================================
키와 값의 쌍을 데이터로 가짐
변경 불가능한 자료형을 키로 사용한다
해시 테이블을 사용, 데이터의 조회 및 수정에 있어 O(1)의 시간에 처리 가능

        data = dict()   # data['key'] = value
        data['사과'] = 'Apple'
        data['파인애플'] = 'Pineapple'
        print(data('사과'))
        data.keys() / data.values()

<집합>===================================================================
중복을 허용하지 않고
순서가 없음

리스트 혹은 문자열을 이용해서 초기화할 수 있음  / set함수 이용
혹은 중괄호 안에 각 원소를 콤마
데이터의 조회 및 수정 O(1)

    data = set([1,2,3,4,4,2,3,2,1,5])
    print(data)
    data = {1,2,3,4,4,2,3,2,1,5}
    print(data)

합집합, 교집합, 차집합 가능  (& |, -)
하나추가, 여러개 추가, 특정 값 삭제는 data.add(4), data.update([5,6]), data.remove(3)

<기본입출력>===================================================================
sys.stdin.readline()을 이용하지만 입력 후 엔터가 줄 바꿈 기호로 입력되므로 rstrip()메서드 함께 사용

<조건부 표현식>===================================================================
score = 85
result = "success" if score>80 else 'Fail'
print(result)


pass : if else 조건문에서 아무것도 안쓰고 넘어가고 싶을 때
continue : 반복문에서 남은 코드의 실행을 건너뛰고 다음 반복을 진행하고자 할 때

<람다표현식>===================================================================
함수를 간단하게 작성 가능하다
print(labda a,b : a+b)

list1 = [1,2,3,4,5]
list2 = [6,7,8,9,10]
result = list(map(lambda a,b:a+b,list1,list2))
print(result)
https://blockdmask.tistory.com/m/520

<내장함수>===================================================================
sum()
min(), max()
eval()  #eval("1+3*4")
sorted(list, reverse = Ture)
sorted(list, key = lambda x:(x[1],x[0]))

<순열과조합>===================================================================
from itertools import permutations
data = [1,2,3]
result = list(permutations(data,2))
print(result)
                                [(1, 2), (1, 3), (2, 1), (2, 3), (3, 1), (3, 2)]

from itertools import combinations
data = [1,2,3]
result = list(combinations(data,2))
print(result)

                                [(1, 2), (1, 3), (2, 3)]

from itertools import product
data = [1,2,3]
result = list(product(data,repeat = 2))
print(result)
                                [(1, 1), (1, 2), (1, 3), (2, 1), (2, 2), (2, 3), (3, 1), (3, 2), (3, 3)]

from itertools import combinations_with_replacement
data = [1,2,3]
result = list(combinations_with_replacement(data,2))
print(result)
                                [(1, 1), (1, 2), (1, 3), (2, 2), (2, 3), (3, 3)]

<counter>===================================================================
<최대공약수와 최대 공배수>===================================================================
